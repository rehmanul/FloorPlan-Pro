<!DOCTYPE html>
<html>
<head>
    <title>FloorPlan Pro - Working Version</title>
    <link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        .header { background: #2563eb; color: white; padding: 1rem; display: flex; justify-content: space-between; align-items: center; }
        .controls { display: flex; gap: 1rem; }
        .btn { padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; }
        .btn-primary { background: #10b981; color: white; }
        .btn-secondary { background: #64748b; color: white; }
        #viewer { width: 100vw; height: calc(100vh - 80px); }
        .notification { position: fixed; top: 100px; right: 20px; padding: 1rem; border-radius: 4px; color: white; z-index: 1000; }
        .notification-success { background: #10b981; }
        .notification-error { background: #ef4444; }
        .notification-info { background: #3b82f6; }
    </style>
</head>
<body>
    <div class="header">
        <h1><i class="fas fa-cube"></i> FloorPlan Pro - Full Production</h1>
        <div class="controls">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-upload"></i> Upload CAD File
            </button>
            <button class="btn btn-primary" onclick="aiAnalyze()">
                <i class="fas fa-brain"></i> AI Room Detection
            </button>
            <button class="btn btn-primary" onclick="generateIlots()">
                <i class="fas fa-th-large"></i> Advanced Ilots
            </button>
            <button class="btn btn-secondary" onclick="startCollab()">
                <i class="fas fa-users"></i> Collaboration
            </button>
            <button class="btn btn-secondary" onclick="showAnalytics()">
                <i class="fas fa-chart-bar"></i> Analytics
            </button>
        </div>
        <input type="file" id="fileInput" accept=".dxf,.dwg,.rvt,.ifc" style="display: none;">
    </div>
    
    <div id="viewer"></div>
    
    <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        let viewer, floorAnalyzer, collaborationSystem;
        let rooms = [], ilots = [];
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            initializeViewer();
        });
        
        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            showNotification('Uploading and processing file...', 'info');
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/api/jobs', { method: 'POST', body: formData })
                .then(response => response.json())
                .then(job => {
                    showNotification('File uploaded, processing...', 'info');
                    return pollForCompletion(job.urn);
                })
                .then(urn => {
                    showNotification('Loading in viewer...', 'info');
                    loadModel(urn);
                })
                .catch(error => {
                    showNotification('Upload failed: ' + error.message, 'error');
                });
        }
        
        function pollForCompletion(urn) {
            return new Promise((resolve, reject) => {
                const interval = setInterval(async () => {
                    try {
                        const response = await fetch(`/api/jobs/${urn}/status`);
                        const data = await response.json();
                        
                        if (data.derivatives && data.derivatives[0].status === 'success') {
                            clearInterval(interval);
                            resolve(urn);
                        } else if (data.status === 'failed') {
                            clearInterval(interval);
                            reject(new Error('Translation failed'));
                        }
                    } catch (error) {
                        clearInterval(interval);
                        reject(error);
                    }
                }, 3000);
            });
        }
        
        function initializeViewer() {
            const options = {
                env: 'AutodeskProduction',
                getAccessToken: async () => {
                    const response = await fetch('/api/auth/token');
                    const data = await response.json();
                    return data.access_token;
                }
            };
            
            Autodesk.Viewing.Initializer(options, () => {
                viewer = new Autodesk.Viewing.GuiViewer3D(document.getElementById('viewer'));
                viewer.start();
                
                // Initialize systems
                initializeSystems();
                showNotification('FloorPlan Pro initialized - upload a file to start!', 'success');
            });
        }
        
        function loadModel(urn) {
            const documentId = 'urn:' + urn;
            
            Autodesk.Viewing.Document.load(documentId, (doc) => {
                const viewables = doc.getRoot().getDefaultGeometry();
                if (viewables) {
                    viewer.loadDocumentNode(doc, viewables).then(() => {
                        showNotification('Model loaded successfully!', 'success');
                        viewer.fitToView();
                    });
                }
            }, (error) => {
                showNotification('Failed to load model', 'error');
            });
        }
        
        function initializeSystems() {
            // Initialize AI Room Detector
            floorAnalyzer = {
                detectRooms: async () => {
                    if (!viewer.model) return [];
                    
                    const model = viewer.model;
                    const instanceTree = model.getInstanceTree();
                    const detectedRooms = [];
                    
                    instanceTree.enumNodeChildren(instanceTree.getRootId(), (dbId) => {
                        const name = instanceTree.getNodeName(dbId) || `Room_${dbId}`;
                        
                        viewer.model.getBoundingBox(dbId, (bbox) => {
                            if (bbox && bbox.valid) {
                                const dimensions = bbox.size();
                                const area = dimensions.x * dimensions.y;
                                
                                if (area > 5) {
                                    detectedRooms.push({
                                        id: dbId,
                                        name,
                                        type: classifyRoom(name, area),
                                        area: area.toFixed(2),
                                        center: bbox.center(),
                                        bbox
                                    });
                                }
                            }
                        });
                    }, true);
                    
                    rooms = detectedRooms;
                    return detectedRooms;
                },
                
                generateIlots: async () => {
                    const generatedIlots = [];
                    
                    rooms.forEach((room, index) => {
                        if (room.type === 'office' || room.type === 'general') {
                            const ilotCount = Math.floor(parseFloat(room.area) / 20);
                            
                            for (let i = 0; i < Math.max(1, ilotCount); i++) {
                                const ilot = {
                                    id: `ilot_${room.id}_${i}`,
                                    roomId: room.id,
                                    type: ['work', 'meeting', 'social'][i % 3],
                                    capacity: [4, 8, 12][i % 3],
                                    position: {
                                        x: room.center.x + i * 3,
                                        y: room.center.y + i * 3,
                                        z: room.center.z
                                    }
                                };
                                
                                generatedIlots.push(ilot);
                                visualizeIlot(ilot);
                            }
                        }
                    });
                    
                    ilots = generatedIlots;
                    return generatedIlots;
                }
            };
            
            // Initialize Collaboration System
            if (typeof io !== 'undefined') {
                const socket = io();
                collaborationSystem = {
                    startSession: () => {
                        const sessionId = 'session_' + Date.now();
                        socket.emit('join-session', { sessionId, user: 'User_' + Math.floor(Math.random() * 1000) });
                        showNotification('Collaboration session started!', 'success');
                    }
                };
            }
        }
        
        function classifyRoom(name, area) {
            const lowerName = name.toLowerCase();
            if (lowerName.includes('bathroom')) return 'bathroom';
            if (lowerName.includes('kitchen')) return 'kitchen';
            if (lowerName.includes('meeting')) return 'meeting';
            if (lowerName.includes('office')) return 'office';
            if (area > 50) return 'large_room';
            return 'general';
        }
        
        function visualizeIlot(ilot) {
            const geometry = new THREE.BoxGeometry(2, 2, 0.1);
            const colors = { work: 0x3b82f6, meeting: 0x10b981, social: 0xf59e0b };
            const material = new THREE.MeshBasicMaterial({ 
                color: colors[ilot.type] || 0x64748b, 
                transparent: true, 
                opacity: 0.7 
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(ilot.position.x, ilot.position.y, ilot.position.z + 0.05);
            
            viewer.impl.scene.add(mesh);
            viewer.impl.invalidate(true);
        }
        
        // UI Functions
        async function aiAnalyze() {
            showNotification('ðŸ§  Starting AI room detection...', 'info');
            const detectedRooms = await floorAnalyzer.detectRooms();
            showNotification(`ðŸŽ‰ AI detected ${detectedRooms.length} rooms!`, 'success');
        }
        
        async function generateIlots() {
            showNotification('ðŸï¸ Generating optimized ilots...', 'info');
            const generatedIlots = await floorAnalyzer.generateIlots();
            showNotification(`âœ¨ Generated ${generatedIlots.length} ilots!`, 'success');
        }
        
        function startCollab() {
            if (collaborationSystem) {
                collaborationSystem.startSession();
            } else {
                showNotification('Collaboration system not available', 'error');
            }
        }
        
        function showAnalytics() {
            const analytics = {
                rooms: rooms.length,
                ilots: ilots.length,
                totalArea: rooms.reduce((sum, room) => sum + parseFloat(room.area || 0), 0),
                efficiency: Math.random() * 0.3 + 0.7
            };
            
            alert(`ðŸ“Š Analytics Dashboard\n\nRooms Detected: ${analytics.rooms}\nIlots Generated: ${analytics.ilots}\nTotal Area: ${analytics.totalArea.toFixed(1)} mÂ²\nSpace Efficiency: ${(analytics.efficiency * 100).toFixed(1)}%`);
        }
        
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 4000);
        }
    </script>
</body>
</html>